# Тестовое задание в PustoStudio на позицию Python разработчика

## Задание 1
Приложение подразумевает ежедневный вход пользователя, начисление баллов за вход. 
Нужно отследить момент первого входа игрока для аналитики. 
Также у игрока имеются игровые бонусы в виде нескольких типов бустов. 
Нужно описать модели игрока и бустов с возможностью начислять игроку бусты 
за прохождение уровней или вручную. 
(Можно написать, применяя sqlalchemy)

``` python
from django.db import models


class Player(models.Model):
    pass
    

class Boost(models.Model):
    pass
```

## Задание 2

Дано несколько моделей

``` python
from django.db import models

class Player(models.Model):
    player_id = models.CharField(max_length=100)
    
    
class Level(models.Model):
    title = models.CharField(max_length=100)
    order = models.IntegerField(default=0)
    
    
    
class Prize(models.Model):
    title = models.CharField()
    
    
class PlayerLevel(models.Model):
    player = models.ForeignKey(Player, on_delete=models.CASCADE)
    level = models.ForeignKey(Level, on_delete=models.CASCADE)
    completed = models.DateField()
    is_completed = models.BooleanField(default=False)
    score = models.PositiveIntegerField(default=0)
    
    
class LevelPrize(models.Model):
    level = models.ForeignKey(Level, on_delete=models.CASCADE)
    prize = models.ForeignKey(Prize, on_delete=models.CASCADE)
    received = models.DateField()  
```

Написать два метода:

1. Присвоение игроку приза за прохождение уровня.
2. Выгрузку в csv следующих данных: id игрока, название уровня, пройден ли уровень, полученный приз за уровень.
Учесть, что записей может быть 100 000 и более.


# Решение
## Задание 1

Модели описал на SQLAlchemy 2.0+
За отсутствием четких требований, постарался сделать универсальное решение

### Модель игрока (Player)
Описание полей:
- `id`: Уникальный идентификатор игрока.
- `created_at`: Время создания аккаунта, автоматически заполняется при создании записи.
- `username`: Уникальное имя пользователя.
- `daily_points`: Количество баллов, накопленных за ежедневные входы.
- `first_login`: Время первого входа пользователя для целей аналитики.
- `next_accrual_available`: Время, когда игрок сможет получить следующие баллы за вход. Это поле помогает управлять циклом начисления баллов, чтобы они начислялись не чаще, чем раз в сутки (или любой другой промежуток времени).

Взаимодействия:
- Отношения с бустами: Игрок может иметь несколько бустов, получаемых за выполнение условий или вручную.
- Отношения с логинами: Игрок может иметь несколько записей о своих входах в систему, что позволяет отслеживать историю входов.

### Модель входов пользователя (PlayerLogin)
Описание полей:
- `id`: Уникальный идентификатор записи о входе.
- `player_id`: Ссылка на игрока, к которому относится запись о входе.
- `login_time`: Время входа пользователя. По умолчанию фиксируется текущее время при создании записи.

Эта модель хранит историю всех входов пользователя в систему. Благодаря ей можно точно знать, когда игрок входил в игру.

### Модель буста (Boost)
Описание полей:
- `id`: Уникальный идентификатор буста.
- `name`: Уникальное название буста.
- `description`: Описание буста, позволяющее игроку понять его назначение.
- `type`: Тип буста 

На тип буста никаких ограничений на уровне базе не накладывал. Можно наложить ограничения со стороны бизнес-логики.
(Какой-нибудь Enum сделать)

### Модель буста игрока (PlayerBoost)
Описание полей:
- `id`: Уникальный идентификатор записи о бусте игрока.
- `player_id`: Ссылка на игрока, которому присвоен буст.
- `boost_id`: Ссылка на буст, который был присвоен игроку.
- `value`: Значение или мощность буста.
- `received_at`: Время получения буста игроком.

Эта модель хранит информацию о том, какие бусты получил игрок, когда он их получил и с каким значением. 
Модель связывает игроков с их бустами и помогает управлять эффектами бустов на игровом процессе.

В значение буста можно передать кол-во процентов, на сколько пунктов, в сколько раз буст увеличивает какую-то характеристику 
в зависимости от его типа.

Можно сказать, что это связь многие ко многим.


## Задание 2

Для этого задания немного изменил модели, которые были предоставлены, так как не очень разобрался какой должен был быть 
флоу работы с той структурой.

После изменения флоу получился примерно такой:
- Есть какие-то уровни, которые игроки могут проходить
- Есть игроки
- Когда игрок начинает проходить уровень, создается запись в таблице `PlayerLevel`
- Когда игрок проходит уровень, для него генерируются призы (например, промокоды) и создаются записи в таблице `LevelPrize`, но призы не попадают сразу к игроку
- После этого игрок может забрать свои призы

Примерный флоу представлен в функции `test_flow` в файле `main.py`

### Присвоение призов за прохождение уровня
Функция дли присвоения призов игроку называется `assign_prizes_to_player`.

Не знаю что про неё рассказать, просто создаёт записи в таблице `LevelPrize`)

Также есть проверки, что все нужные записи существуют

### Экспорт в csv
Функция для экспорта называется `export_player_levels_to_csv`

Шаги выполнения:
1. **Открытие файла CSV.** Файл открывается для записи с указанием кодировки `utf-8`, чтобы поддерживать запись любых символов.
2. **Запись заголовков.** Первой строкой в CSV-файл записываются заголовки колонок: `player_id`, `level_title`, `is_completed`, и `prize_title`.
3. **Формирование SQL-запроса**. Запрос получает только необходимые данные из нескольких таблиц:
   - `Player`: для получения информации об игроке.
   - `PlayerLevel`: для получения информации о пройденных уровнях.
   - `Level`: для получения названия уровня.
   - `LevelPrize` и `Prize`: для получения информации о полученных призах. Если игрок не получил приз за уровень, используется `outerjoin` для того, чтобы вернуть `NULL`, который затем преобразуется в строку 'No Prize'.
4. **Частичная загрузка данных.** Чтобы обработать большое количество записей, используется метод `yield_per(chunk_size)`, который поэтапно загружает по `chunk_size` строк за раз, что снижает нагрузку на память.
5. **Запись строк в CSV.** Каждая строка, содержащая данные о игроке, уровне, статусе прохождения и названии приза (или сообщении No Prize, если приз не был получен), записывается в CSV.
6. **Возврат пути к файлу.** После завершения процесса возвращается путь к созданному CSV-файлу.


## Контакты
- [Telegram - @printeromg](https://t.me/printeromg)
- [Почта - kitaev.gregory@gmail.com](mailto:kitaev.gregory@gmail.com)
